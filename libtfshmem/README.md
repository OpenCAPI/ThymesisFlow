## LibTFShmem: a library enabling shared memory on Thymesisflow

This library enables creating a shared memory segment across processes running on two
machines interfaced via ThymesisFlow. The idea is that the two processes will be able
to map a buffer in memory and access it concurrently.
ALthough this is possible, there are a few caveats to take into consideration:
- memory accesses across the two machines are neither coherent nor consistent by nature.
  It will be up-to the programmer to make sure memory is properly handled.
- (unexpectedly) The data-cache is your worst enemy here. The two sides sharing memory
  might as well keep accessing a local copy of the shared data in their data cache as
  no cache-coherence protocol is in place across the two machines. It will be again up-to
  the programmer to make sure data is casted out from one processor cache before the
  other side can be aware of it. There are sample applications showing how to deal with
  the cache, have a look [here](libtfshmem/test).
  - Do not try make the mapping un-cacheable by hacking the mmap in [here](libtfshmem/kernel_module),
    as this would make the side borrowing memory (a.k.a. the compute) fail miserably at
    the first memory access. ThymesisFlow is only supporting 128B memory transactions and
    and disabling the data cache does not help enforcing this.

Having said that, have fun experimentign with shared memory on thymesisflow. 

### Overview
This library is composed of two main parts: a user-space library (libtfshmem) and a kernel module (tfshmem). As you might already
know at this stage, ThymesisFlow is divided in the compute (borrower) and memory node (lender). The user-space
library is needed on both sides, while the kernel module is needed only on the compute node. The reason being the memory node
accesses the shared memory locally, while the compute node needs something to map the shared memory into processes VA space.
When using this library there's no need for you to start the thymesisflow-agent or to use the CLI, the only thing you need to do
yourself is to make sure the memory node is initialized first, send the EA (Effective Address) generated over to the application runnning on the compute
node and execute the initialization in there.
Have a look at the examples [here](libtfshmem/test).

### How-to compile the library
First make sure you have compiled `libthymesisflow`. Then just run `make` in this folder.
There's a `DEBUG` flag in the Makefile that is set to 1 by default. Set it to 0 if you want
a less verbose but **less informative** run.
Have a look at the makefile for more details.

### How-to compile the kernel module
Building the kernel module is as easy as running `make`. The Makefile will default the `KDIR` to the location where you running kernel build files are located.
If you want to build for another kernel you can run:
```
make KDIR=/path/to/configured/kernel
```

the kernel odule can be manually probed with:
```
insmod tfshmem.ko
```
or automatically at machine boot by typing:
```
make install
```

in both cases a sign of success is if you can find the below device:
```
/dev/tfshmem
```

if not `dmesg` is your best friend.

Please note ***installing this module will taint your kernel*** and it is strongly discouraged on production machines (i.e., machines running services people rely on).
The module itself, before you start using it, is relatively harmless. However, your machine could crash when you start operating it. 

***Install this module at your own risk***.

### Test applications
There are test applications for you to get a taste on how to use it. The documentation is the code :D.

Tips:
- make sure you initialize the memory node first and the compute after.
- The EA generated by the memroy node at initialization is needed for initializing the compute node. 
